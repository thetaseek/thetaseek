{"version":3,"sources":["store/websocket.js","components/Websocket.js","store/tickers.js","services/deribit-utils.js","services/deribit.js","store/instruments.js","components/OptionsTable.js","App.js","store/store.js","serviceWorker.js","index.js","services/reconnecting-websocket.js"],"names":["slice","createSlice","name","initialState","isOpen","reducers","open","state","close","actions","selectors","websocket","Websocket","useSelector","tickers","update","payload","instrumentName","transformReply","r","isPlainObject","reduce","result","value","key","camelCase","isArray","map","x","socket","ReconnectingWebsocket","automaticOpen","ws","reconnect","timer","interval","allowance","resetTimer","clearTimeout","setTimeout","console","warn","addEventListener","send","JSON","stringify","method","params","Math","max","parseInt","jsonrpc","id","Date","now","event","message","parse","data","type","manageSession","refresh","subscriptions","channels","Object","keys","channel","log","instruments","success","dispatch","request","timeout","Promise","resolve","reject","Error","readyState","once","callback","removeEventListener","call","currency","kind","expired","then","Option","ticker","selector","bestBidAmount","bestBidPrice","bestAskPrice","bestAskAmount","OptionsTable","useDispatch","all","expiry","min","expirationTimestamp","filter","rows","groupBy","React","useEffect","length","channelArg","handler","castArray","forEach","i","subscriptionAdd","d","subscriptionRemove","toUTCString","cellPadding","s","find","optionType","put","App","debug","className","configureStore","reducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","store","document","getElementById","navigator","serviceWorker","ready","registration","unregister","define","ReconnectingWebSocket","prototype","onopen","onclose","onconnecting","onmessage","onerror","debugAll","CONNECTING","WebSocket","OPEN","CLOSING","CLOSED","url","protocols","options","settings","reconnectInterval","maxReconnectInterval","reconnectDecay","timeoutInterval","maxReconnectAttempts","binaryType","this","reconnectAttempts","protocol","self","forcedClose","timedOut","eventTarget","createElement","generateEvent","args","evt","createEvent","initCustomEvent","bind","dispatchEvent","reconnectAttempt","localWs","e","isReconnect","code","reason","wasClean","pow"],"mappings":"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","file":"static/js/main.c60249b2.chunk.js","sourcesContent":["import {createSlice} from \"@reduxjs/toolkit\";\n\nconst slice = createSlice({\n  name: \"websocket\",\n  initialState: {\n    isOpen: false,\n  },\n  reducers: {\n    open: (state) => {\n      state.isOpen = true;\n    },\n    close: (state) => {\n      state.isOpen = false;\n    },\n  },\n});\n\nexport const actions = slice.actions;\n\nexport const selectors = {\n  isOpen: (state) => state.websocket.isOpen,\n};\n\nexport default slice.reducer;\n","import React from \"react\";\nimport {useSelector} from \"react-redux\";\n\nimport {selectors} from \"../store/websocket\";\n\nexport function Websocket() {\n  const isOpen = useSelector(selectors.isOpen);\n  return <div>Connection Status: {isOpen ? \"Open\" : \"Closed\"}</div>;\n}\n","import {createSlice} from \"@reduxjs/toolkit\";\n\n// Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n// doesn't actually mutate the state because it uses the Immer library,\n// which detects changes to a \"draft state\" and produces a brand new\n// immutable state based off those changes\nconst slice = createSlice({\n  name: \"tickers\",\n  initialState: {\n    tickers: {},\n  },\n  reducers: {\n    update: (state, {payload}) => {\n      state.tickers[payload.instrumentName] = payload;\n    },\n  },\n});\n\nexport const actions = slice.actions;\n\nexport const tickerSelectorFactory = (ticker) => (state) =>\n  state.tickers.tickers[ticker] || {};\n\nexport const selectors = {\n  instruments: (state) => state.instruments.instruments,\n};\n\nexport default slice.reducer;\n","import camelCase from \"lodash/camelCase\";\nimport isArray from \"lodash/isArray\";\nimport isPlainObject from \"lodash/isPlainObject\";\nimport reduce from \"lodash/reduce\";\n\n// Recursively transform all keys to camelcase\nexport const transformReply = (r) => {\n  if (isPlainObject(r)) {\n    return reduce(\n      r,\n      (result, value, key) => {\n        result[camelCase(key)] = transformReply(value);\n        return result;\n      },\n      {}\n    );\n  }\n\n  // If its a array, transform each element\n  if (isArray(r)) {\n    return r.map((x) => transformReply(x));\n  }\n\n  // Just return base type\n  return r;\n};\n\n// Manages Deribit websocket and reconnects if stale\nexport const manageSession = (ws, reconnect = () => {\n}) => {\n  // Set a timer, if no messages received within interval, refresh connection\n  let timer = null;\n  const interval = 10 * 1000;\n  const allowance = 2000; // Allowance for network\n\n  const resetTimer = () => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      console.warn(\n        `Connection is stale, no message received in ${interval / 1000} seconds`\n      );\n      return reconnect();\n    }, interval + allowance);\n  };\n\n  // Once connection opens, start requesting heartbeats\n  ws.addEventListener(\"open\", () => {\n    ws.send(\n      JSON.stringify({\n        method: \"public/set_heartbeat\",\n        params: {\n          // Seconds (min is 10s)\n          interval: Math.max(parseInt(interval / 1000, 10), 10),\n        },\n        jsonrpc: \"2.0\",\n        id: Date.now(),\n      })\n    );\n  });\n\n  // When connection closes, remove my timer\n  ws.addEventListener(\"close\", () => {\n    clearTimeout(timer);\n  });\n\n  // Listen for messages\n  ws.addEventListener(\"message\", function (event) {\n    // Reset timer on new message\n    resetTimer();\n\n    // I must respond to test_request messages to keep connection alive\n    const message = JSON.parse(event.data);\n    if (\n      message.method === \"heartbeat\" &&\n      message.params.type === \"test_request\"\n    ) {\n      ws.send(\n        JSON.stringify({\n          method: \"public/test\",\n          params: {},\n          jsonrpc: \"2.0\",\n          id: Date.now(),\n        })\n      );\n    }\n  });\n};\n","import castArray from \"lodash/castArray\";\nimport isArray from \"lodash/isArray\";\nimport ReconnectingWebsocket from \"./reconnecting-websocket\";\nimport {manageSession, transformReply} from \"./deribit-utils\";\n\nconst socket = new ReconnectingWebsocket(\n  // \"wss://www.deribit.com/ws/api/v2\",\n  \"wss://test.deribit.com/ws/api/v2\",\n  null,\n  {\n    automaticOpen: false,\n  }\n);\n\nmanageSession(socket, socket.refresh);\n\n// Manage subscriptions\n\n// Key is the channel, value is function handler\nconst subscriptions = {};\nsocket.addEventListener(\"open\", (event) => {\n  socket.send(\n    JSON.stringify({\n      method: \"public/subscribe\",\n      params: {\n        channels: Object.keys(subscriptions),\n      },\n      jsonrpc: \"2.0\",\n      id: Date.now(),\n    })\n  );\n});\n\nsocket.addEventListener(\"message\", (event) => {\n  const message = JSON.parse(event.data);\n  if (message.method === \"subscription\") {\n    const {channel, data} = message.params;\n    if (subscriptions[channel]) {\n      subscriptions[channel](transformReply(data));\n    } else {\n      console.log(\"Ignoring subscription: \", channel);\n    }\n  }\n});\n\nexport const subscriptionAdd = (channelArg, handler) => {\n  const channels = castArray(channelArg);\n  channels.forEach((channel, i) => {\n    subscriptions[channel] = isArray(handler) ? handler[i] : handler;\n  });\n\n  socket.send(\n    JSON.stringify({\n      method: \"public/subscribe\",\n      params: {\n        channels,\n      },\n      jsonrpc: \"2.0\",\n      id: Date.now(),\n    })\n  );\n};\n\nexport const subscriptionRemove = (channelArg) => {\n  const channels = castArray(channelArg);\n  channels.forEach((channel) => {\n    delete channels[channel];\n  });\n\n  socket.send(\n    JSON.stringify({\n      method: \"public/unsubscribe\",\n      params: {\n        channels,\n      },\n      jsonrpc: \"2.0\",\n      id: Date.now(),\n    })\n  );\n};\n\n// Function to make a rpc call over ws. Will resolve with response\nexport const call = (request, {timeout = 10000} = {}) =>\n  new Promise((resolve, reject) => {\n    const timer = setTimeout(reject, timeout, new Error(\"Call timed out\"));\n\n    const id = Date.now();\n    const payload = JSON.stringify({\n      method: request.method,\n      params: request.params,\n      jsonrpc: \"2.0\",\n      id,\n    });\n\n    function callback(event) {\n      const message = JSON.parse(event.data);\n      if (message.id === id) {\n        socket.removeEventListener(\"message\", callback);\n        clearTimeout(timer);\n        return resolve(message);\n      }\n    }\n\n    // If connection is open send, otherwise wait for connection to open;\n    if (socket.readyState === 1) {\n      socket.send(payload);\n    } else {\n      // Connection opened\n      socket.addEventListener(\"open\", () => socket.send(payload), {\n        once: true,\n      });\n    }\n\n    socket.addEventListener(\"message\", callback);\n  });\n\nexport default socket;\n","import {createSlice} from \"@reduxjs/toolkit\";\nimport {call} from \"../services/deribit\";\nimport {transformReply} from \"../services/deribit-utils\";\n\n// Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n// doesn't actually mutate the state because it uses the Immer library,\n// which detects changes to a \"draft state\" and produces a brand new\n// immutable state based off those changes\nconst slice = createSlice({\n  name: \"instruments\",\n  initialState: {\n    instruments: [],\n  },\n  reducers: {\n    success: (state, {payload}) => {\n      state.instruments = payload;\n    },\n  },\n});\n\nexport const actions = {\n  request: () => (dispatch) => {\n    call({\n      method: \"public/get_instruments\",\n      params: {\n        currency: \"BTC\",\n        kind: \"option\",\n        expired: false,\n      },\n    })\n      .then((r) => r.result)\n      .then(transformReply)\n      .then((r) => dispatch(slice.actions.success(r)));\n  },\n};\n\nexport const selectors = {\n  instruments: (state) => state.instruments.instruments,\n};\n\nexport default slice.reducer;\n","import React from \"react\";\nimport groupBy from \"lodash/groupBy\";\nimport map from \"lodash/map\";\nimport {useSelector, useDispatch} from \"react-redux\";\n\nimport {actions as tickers} from \"../store/tickers\";\nimport {actions, selectors} from \"../store/instruments\";\nimport {subscriptionAdd, subscriptionRemove} from \"../services/deribit\";\nimport {tickerSelectorFactory} from \"../store/tickers\";\n\nconst Option = ({instrumentName}) => {\n  const selector = tickerSelectorFactory(instrumentName);\n  const data = useSelector(selector);\n  return (\n    <>\n      <td>{data.bestBidAmount || \"-\"}</td>\n      <td>{data.bestBidPrice || \"-\"}</td>\n      <td>{data.bestAskPrice || \"-\"}</td>\n      <td>{data.bestAskAmount || \"-\"}</td>\n    </>\n  );\n};\n\nexport function OptionsTable() {\n  const dispatch = useDispatch();\n  const all = useSelector(selectors.instruments);\n\n  const expiry = Math.min(...all.map((x) => x.expirationTimestamp));\n  const instruments = all.filter((x) => x.expirationTimestamp === expiry);\n\n  const rows = groupBy(instruments, \"strike\");\n\n  React.useEffect(() => {\n    dispatch(actions.request());\n  }, [dispatch]);\n\n  React.useEffect(() => {\n    if (instruments.length > 0) {\n      const channels = instruments.map((x) => `ticker.${x.instrumentName}.raw`);\n      subscriptionAdd(channels, (d) => dispatch(tickers.update(d)));\n      return () => subscriptionRemove(channels);\n    }\n    return () => {\n    };\n  }, [dispatch, instruments]);\n\n  return (\n    <div>\n      <h6>{new Date(expiry).toUTCString()}</h6>\n      <table cellPadding=\"10\">\n        <thead>\n        <tr>\n          <th>Size</th>\n          <th>Bid</th>\n          <th>Ask</th>\n          <th>Size</th>\n          <th>Strike</th>\n          <th>Size</th>\n          <th>Bid</th>\n          <th>Ask</th>\n          <th>Size</th>\n        </tr>\n        </thead>\n        <tbody>\n        {map(rows, (data, s) => {\n          const call = data.find((x) => x.optionType === \"call\")\n            .instrumentName;\n          const put = data.find((x) => x.optionType === \"put\").instrumentName;\n          return (\n            <tr key={s}>\n              <Option instrumentName={call}/>\n              <td>{` ${s} `}</td>\n              <Option instrumentName={put}/>\n            </tr>\n          );\n        })}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport {Websocket} from \"./components/Websocket\";\nimport {OptionsTable} from \"./components/OptionsTable\";\nimport {useDispatch} from \"react-redux\";\nimport socket from \"./services/deribit\";\nimport {actions} from \"./store/websocket\";\n\nfunction App() {\n  const dispatch = useDispatch();\n  React.useEffect(() => {\n    socket.open();\n\n    socket.addEventListener(\"open\", () => {\n      dispatch(actions.open());\n      console.debug(\"Connection to Deribit opened\");\n    });\n\n    socket.addEventListener(\n      \"close\",\n      () => {\n        dispatch(actions.close());\n        console.debug(\"Connection to Deribit closed\");\n      },\n      {once: true}\n    );\n\n    return () => {\n      console.log(\"Closing connection to Deribit\");\n      socket.close();\n    };\n  }, [dispatch]);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Websocket/>\n        <OptionsTable/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import {configureStore} from \"@reduxjs/toolkit\";\nimport instruments from \"./instruments\";\nimport tickers from \"./tickers\";\nimport websocket from \"./websocket\";\n\nexport default configureStore({\n  reducer: {\n    instruments,\n    tickers,\n    websocket,\n  },\n});\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n  // [::1] is the IPv6 localhost address.\r\n  window.location.hostname === '[::1]' ||\r\n  // 127.0.0.0/8 are considered localhost for IPv4.\r\n  window.location.hostname.match(\r\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n  )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: {'Service-Worker': 'script'},\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport store from './store/store';\r\nimport {Provider} from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App/>\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","/* eslint-disable */\r\n// https://raw.githubusercontent.com/joewalnes/reconnecting-websocket/master/reconnecting-websocket.js\r\n// MIT License:\r\n//\r\n// Copyright (c) 2010-2012, Joe Walnes\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\n/**\r\n * This behaves like a WebSocket in every way, except if it fails to connect,\r\n * or it gets disconnected, it will repeatedly poll until it successfully connects\r\n * again.\r\n *\r\n * It is API compatible, so when you have:\r\n *   ws = new WebSocket('ws://....');\r\n * you can replace with:\r\n *   ws = new ReconnectingWebSocket('ws://....');\r\n *\r\n * The event stream will typically look like:\r\n *  onconnecting\r\n *  onopen\r\n *  onmessage\r\n *  onmessage\r\n *  onclose // lost connection\r\n *  onconnecting\r\n *  onopen  // sometime later...\r\n *  onmessage\r\n *  onmessage\r\n *  etc...\r\n *\r\n * It is API compatible with the standard WebSocket API, apart from the following members:\r\n *\r\n * - `bufferedAmount`\r\n * - `extensions`\r\n * - `binaryType`\r\n *\r\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\r\n * - Joe Walnes\r\n *\r\n * Syntax\r\n * ======\r\n * var socket = new ReconnectingWebSocket(url, protocols, options);\r\n *\r\n * Parameters\r\n * ==========\r\n * url - The url you are connecting to.\r\n * protocols - Optional string or array of protocols.\r\n * options - See below\r\n *\r\n * Options\r\n * =======\r\n * Options can either be passed upon instantiation or set after instantiation:\r\n *\r\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\r\n *\r\n * or\r\n *\r\n * var socket = new ReconnectingWebSocket(url);\r\n * socket.debug = true;\r\n * socket.reconnectInterval = 4000;\r\n *\r\n * debug\r\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\r\n *\r\n * automaticOpen\r\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\r\n *\r\n * reconnectInterval\r\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\r\n *\r\n * maxReconnectInterval\r\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\r\n *\r\n * reconnectDecay\r\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\r\n *\r\n * timeoutInterval\r\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\r\n *\r\n */\r\n(function (global, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    define([], factory);\r\n  } else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = factory();\r\n  } else {\r\n    global.ReconnectingWebSocket = factory();\r\n  }\r\n})(this, function () {\r\n\r\n  if (!('WebSocket' in window)) {\r\n    return;\r\n  }\r\n\r\n  function ReconnectingWebSocket(url, protocols, options) {\r\n\r\n    // Default settings\r\n    var settings = {\r\n\r\n      /** Whether this instance should log debug messages. */\r\n      debug: false,\r\n\r\n      /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\r\n      automaticOpen: true,\r\n\r\n      /** The number of milliseconds to delay before attempting to reconnect. */\r\n      reconnectInterval: 1000,\r\n      /** The maximum number of milliseconds to delay a reconnection attempt. */\r\n      maxReconnectInterval: 30000,\r\n      /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\r\n      reconnectDecay: 1.5,\r\n\r\n      /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\r\n      timeoutInterval: 2000,\r\n\r\n      /** The maximum number of reconnection attempts to make. Unlimited if null. */\r\n      maxReconnectAttempts: null,\r\n\r\n      /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */\r\n      binaryType: 'blob'\r\n    }\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    // Overwrite and define settings with options if they exist.\r\n    for (var key in settings) {\r\n      if (typeof options[key] !== 'undefined') {\r\n        this[key] = options[key];\r\n      } else {\r\n        this[key] = settings[key];\r\n      }\r\n    }\r\n\r\n    // These should be treated as read-only properties\r\n\r\n    /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\r\n    this.url = url;\r\n\r\n    /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\r\n    this.reconnectAttempts = 0;\r\n\r\n    /**\r\n     * The current state of the connection.\r\n     * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\r\n     * Read only.\r\n     */\r\n    this.readyState = WebSocket.CONNECTING;\r\n\r\n    /**\r\n     * A string indicating the name of the sub-protocol the server selected; this will be one of\r\n     * the strings specified in the protocols parameter when creating the WebSocket object.\r\n     * Read only.\r\n     */\r\n    this.protocol = null;\r\n\r\n    // Private state variables\r\n\r\n    var self = this;\r\n    var ws;\r\n    var forcedClose = false;\r\n    var timedOut = false;\r\n    var eventTarget = document.createElement('div');\r\n\r\n    // Wire up \"on*\" properties as event handlers\r\n\r\n    eventTarget.addEventListener('open', function (event) {\r\n      self.onopen(event);\r\n    });\r\n    eventTarget.addEventListener('close', function (event) {\r\n      self.onclose(event);\r\n    });\r\n    eventTarget.addEventListener('connecting', function (event) {\r\n      self.onconnecting(event);\r\n    });\r\n    eventTarget.addEventListener('message', function (event) {\r\n      self.onmessage(event);\r\n    });\r\n    eventTarget.addEventListener('error', function (event) {\r\n      self.onerror(event);\r\n    });\r\n\r\n    // Expose the API required by EventTarget\r\n\r\n    this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\r\n    this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\r\n    this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\r\n\r\n    /**\r\n     * This function generates an event that is compatible with standard\r\n     * compliant browsers and IE9 - IE11\r\n     *\r\n     * This will prevent the error:\r\n     * Object doesn't support this action\r\n     *\r\n     * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\r\n     * @param s String The name that the event should use\r\n     * @param args Object an optional object that the event will use\r\n     */\r\n    function generateEvent(s, args) {\r\n      var evt = document.createEvent(\"CustomEvent\");\r\n      evt.initCustomEvent(s, false, false, args);\r\n      return evt;\r\n    };\r\n\r\n    this.open = function (reconnectAttempt) {\r\n      ws = new WebSocket(self.url, protocols || []);\r\n      ws.binaryType = this.binaryType;\r\n\r\n      if (reconnectAttempt) {\r\n        if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\r\n          return;\r\n        }\r\n      } else {\r\n        eventTarget.dispatchEvent(generateEvent('connecting'));\r\n        this.reconnectAttempts = 0;\r\n      }\r\n\r\n      if (self.debug || ReconnectingWebSocket.debugAll) {\r\n        console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\r\n      }\r\n\r\n      var localWs = ws;\r\n      var timeout = setTimeout(function () {\r\n        if (self.debug || ReconnectingWebSocket.debugAll) {\r\n          console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\r\n        }\r\n        timedOut = true;\r\n        localWs.close();\r\n        timedOut = false;\r\n      }, self.timeoutInterval);\r\n\r\n      ws.onopen = function (event) {\r\n        clearTimeout(timeout);\r\n        if (self.debug || ReconnectingWebSocket.debugAll) {\r\n          console.debug('ReconnectingWebSocket', 'onopen', self.url);\r\n        }\r\n        self.protocol = ws.protocol;\r\n        self.readyState = WebSocket.OPEN;\r\n        self.reconnectAttempts = 0;\r\n        var e = generateEvent('open');\r\n        e.isReconnect = reconnectAttempt;\r\n        reconnectAttempt = false;\r\n        eventTarget.dispatchEvent(e);\r\n      };\r\n\r\n      ws.onclose = function (event) {\r\n        clearTimeout(timeout);\r\n        ws = null;\r\n        if (forcedClose) {\r\n          self.readyState = WebSocket.CLOSED;\r\n          eventTarget.dispatchEvent(generateEvent('close'));\r\n        } else {\r\n          self.readyState = WebSocket.CONNECTING;\r\n          var e = generateEvent('connecting');\r\n          e.code = event.code;\r\n          e.reason = event.reason;\r\n          e.wasClean = event.wasClean;\r\n          eventTarget.dispatchEvent(e);\r\n          if (!reconnectAttempt && !timedOut) {\r\n            if (self.debug || ReconnectingWebSocket.debugAll) {\r\n              console.debug('ReconnectingWebSocket', 'onclose', self.url);\r\n            }\r\n            eventTarget.dispatchEvent(generateEvent('close'));\r\n          }\r\n\r\n          var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\r\n          setTimeout(function () {\r\n            self.reconnectAttempts++;\r\n            self.open(true);\r\n          }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\r\n        }\r\n      };\r\n      ws.onmessage = function (event) {\r\n        if (self.debug || ReconnectingWebSocket.debugAll) {\r\n          console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\r\n        }\r\n        var e = generateEvent('message');\r\n        e.data = event.data;\r\n        eventTarget.dispatchEvent(e);\r\n      };\r\n      ws.onerror = function (event) {\r\n        if (self.debug || ReconnectingWebSocket.debugAll) {\r\n          console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\r\n        }\r\n        eventTarget.dispatchEvent(generateEvent('error'));\r\n      };\r\n    }\r\n\r\n    // Whether or not to create a websocket upon instantiation\r\n    if (this.automaticOpen == true) {\r\n      this.open(false);\r\n    }\r\n\r\n    /**\r\n     * Transmits data to the server over the WebSocket connection.\r\n     *\r\n     * @param data a text string, ArrayBuffer or Blob to send to the server.\r\n     */\r\n    this.send = function (data) {\r\n      if (ws) {\r\n        if (self.debug || ReconnectingWebSocket.debugAll) {\r\n          console.debug('ReconnectingWebSocket', 'send', self.url, data);\r\n        }\r\n        return ws.send(data);\r\n      } else {\r\n        throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt, if any.\r\n     * If the connection is already CLOSED, this method does nothing.\r\n     */\r\n    this.close = function (code, reason) {\r\n      // Default CLOSE_NORMAL code\r\n      if (typeof code == 'undefined') {\r\n        code = 1000;\r\n      }\r\n      forcedClose = true;\r\n      if (ws) {\r\n        ws.close(code, reason);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Additional public API method to refresh the connection if still open (close, re-open).\r\n     * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\r\n     */\r\n    this.refresh = function () {\r\n      if (ws) {\r\n        ws.close();\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\r\n   * this indicates that the connection is ready to send and receive data.\r\n   */\r\n  ReconnectingWebSocket.prototype.onopen = function (event) {\r\n  };\r\n  /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\r\n  ReconnectingWebSocket.prototype.onclose = function (event) {\r\n  };\r\n  /** An event listener to be called when a connection begins being attempted. */\r\n  ReconnectingWebSocket.prototype.onconnecting = function (event) {\r\n  };\r\n  /** An event listener to be called when a message is received from the server. */\r\n  ReconnectingWebSocket.prototype.onmessage = function (event) {\r\n  };\r\n  /** An event listener to be called when an error occurs. */\r\n  ReconnectingWebSocket.prototype.onerror = function (event) {\r\n  };\r\n\r\n  /**\r\n   * Whether all instances of ReconnectingWebSocket should log debug messages.\r\n   * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\r\n   */\r\n  ReconnectingWebSocket.debugAll = false;\r\n\r\n  ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\r\n  ReconnectingWebSocket.OPEN = WebSocket.OPEN;\r\n  ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\r\n  ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\r\n\r\n  return ReconnectingWebSocket;\r\n});\r\n"],"sourceRoot":""}